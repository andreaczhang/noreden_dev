---
title: "Flexible input with function factory"
format: 
  html:
    code-fold: false
    code-tools: false
editor: source
---


When we want to make systematic production of constraints for the optimization, it is important to use functions. Given the special requirement as input when the constraint function enters the algorithm, where the argument is `x` and output is a scalar value, we need to **treat this function as an object** produced by our function factory - so that we can tweak the elements *outside* the function itself. 

The basic structure looks like this. 

```{r}
#| label: f_make_constraints
#| echo: true
#| eval: false

f_make_constraints <- function(input_data, tag_outcomes){
  
  
  # this is the function we want to return
  f_ineq <- function (x) {
    
    # a few computed constraints, where x is the new diet
    # it should be the complete set of constrants, 
    # as we select in the last step from 
    tag1_const_lwr <- - sum(x * input_data$per_unit_tag1) + input_data$lwrc_tag1
    tag1_const_upr <- sum(x * input_data$per_unit_tag1) - input_data$uprc_tag1
    
    tag2_const_lwr <- - sum(x * input_data$per_unit_tag2) + input_data$lwrc_tag2
    tag2_const_upr <- sum(x * input_data$per_unit_tag2) - input_data$uprc_tag2

    # collect in a named vector
    constr_all <- c(
      tag1_lwr = tag1_const_lwr, 
      tag1_upr = tag1_const_upr, 
      tag2_lwr = tag2_const_lwr, 
      tag2_upr = tag2_const_upr
    )
    
    # key step:
    # select the ones that we want, for example, tag1
    # need to watch out for the names 
    tags_lwr <- paste0(tag_outcomes, '_lwr')
    tags_upr <- paste0(tag_outcomes, '_upr')
    
    constr <- constr_all[c(tags_lwr, tags_upr)]
    
    return (constr)
  }
  
  # possibly better to also return the input
  return(f_ineq)
}
```

When calling function, can do this

```{r}
#| label: make_constraints_eg
#| echo: true
#| eval: false

# in this setting, the input data must have the columns required by the ff
f_inequalc_tag1 <- f_make_constraints(tag_outcomes = 'tag1', input_data)
f_inequalc_tag1_tag2 <- f_make_constraints(tag_outcomes = c('tag1', 'tag2'), input_data)
```

TO DO: 

* add name checker for the input
* add return arguments for reference 



## An example of a function factory

```{r}
#| label: ff
#| echo: true
#| eval: true

f_out <- function(x, constant){
  f <- function(y){
    res <- y ^ x + constant
    return(res)
  }
  return(f)
}
```


```{r}
#| label: ff_run
#| echo: true
#| eval: true

# it creates a function that at its core, the inner function
# create a function that raise to the power of 2
# 3^2 + 1
f_out1 <- f_out(x = 2, constant = 1) 
f_out1(y=3)

# create a function that raise to the power of 1
# 3^1 + 1
f_out2 <- f_out(x=1, constant = 1) 
f_out2(y=3)
```

